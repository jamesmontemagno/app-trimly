# TrimTally Widget Implementation Plan

This document outlines a concrete, end-to-end plan for integrating the TrimTally home screen widget with the existing SwiftData + CloudKit stack. The goal is to make the widget show the user	s current weight, delta, and trend using the same underlying data and analytics as the main app, while keeping the implementation maintainable.

## Goals

- Show current weight, recent change (delta), and trend in small/medium widgets.
- Use the same data source as the main app:
  - SwiftData models: `WeightEntry`, `Goal`, `AppSettings`.
  - CloudKit-backed storage using `iCloud.com.refractored.trimtally`.
- Minimize duplication of analytics logic (re-use `WeightAnalytics` where practical).
- Keep widget reads lightweight and read-only.
- Ensure widgets stay fresh when the user logs new entries.

## High-Level Architecture

- **Widget extension target**
  - New target: `TrimTallyWidgetExtension` (name can be adjusted).
  - Platform: iOS (or Multiplatform if desired); hosts home screen widgets.
  - Contains a `WidgetBundle` + `Widget` type and `TimelineProvider` implementation.

- **Data source**
  - Option A (recommended for v1): The widget creates its own `ModelContainer` using the same SwiftData schema and CloudKit configuration as the main app.
    - Pros: No extra storage format; multi-device sync built in.
    - Cons: Slightly heavier initialization cost versus a simple UserDefaults read.
  - Option B (optional optimization later): Main app writes a summary payload into `UserDefaults(suiteName: "group.com.refractored.trimtally")`, widget reads that summary.

- **Analytics**
  - Re-use `WeightAnalytics` or a subset of its logic to compute:
    - Latest weight.
    - Delta over a configurable lookback window (e.g., 7 days).
    - Trend direction (downward / upward / stable).

- **Refresh strategy**
  - System-driven: Widget timeline policy `.after(nextUpdate)` (e.g., every 30–60 minutes).
  - App-driven: When the app saves a new `WeightEntry`, call `WidgetCenter.shared.reloadTimelines(ofKind: "TrimlyWidget")` to request an immediate refresh.

---

## Step 1: Create the Widget Extension Target

1. Open `TrimTally.xcodeproj` in Xcode.
2. Go to **File → New → Target...**.
3. Select **Widget Extension** (under iOS or Multiplatform → Application Extension).
4. Configure the new target:
   - Product Name: `TrimTallyWidgetExtension`.
   - Embedded in Application: `TrimTally`.
   - Language: Swift.
   - Disable the option to include a separate host app (if prompted).
5. Finish the wizard.

Xcode will add:
- A new target `TrimTallyWidgetExtension` to the project.
- A starter Swift file (e.g., `TrimTallyWidgetExtension.swift`) containing a `WidgetBundle` and basic widget.

> **Note:** The existing file `Trimly/Widget/TrimlyWidget.swift` is not currently part of any widget extension. It should be wired into this new target in a later step.

---

## Step 2: Wire Up the Existing Widget Swift File

1. In Xcode Project Navigator, locate [Trimly/Widget/TrimlyWidget.swift](../Trimly/Widget/TrimlyWidget.swift).
2. Open the **File Inspector** and under **Target Membership**, check the box for the new `TrimTallyWidgetExtension` target.
3. Optionally uncheck the main `TrimTally` app target for this file, so it lives purely in the extension.
4. In the widget extension target’s source group, you can either:
   - Move `TrimlyWidget.swift` into the widget target group, **or**
   - Leave it physically in the `Trimly/Widget` folder and just rely on target membership.
5. Remove or adapt the autogenerated starter widget Swift file to avoid duplicate widget definitions:
   - If you keep `TrimlyWidget` as your primary widget, delete the auto-generated `SimpleEntry`/`Provider`/`<AppName>Widget` types to avoid naming/conflict issues.

At this point, the extension target should build with the placeholder widget data already present in `TrimlyWidget.swift`.

---

## Step 3: Configure Widget Entitlements

The widget extension must have compatible entitlements with the main app so it can access:
- The same CloudKit container: `iCloud.com.refractored.trimtally`.
- The same app group: `group.com.refractored.trimtally` (for any future shared storage).

1. Select the `TrimTallyWidgetExtension` target in Xcode.
2. Go to **Signing & Capabilities**.
3. Add **App Groups** capability:
   - Check or add the group: `group.com.refractored.trimtally`.
4. Add **iCloud** capability:
   - Enable **CloudKit** under Services.
   - Under Containers, select `iCloud.com.refractored.trimtally`.
5. Confirm that Xcode generates a widget entitlements file (e.g., `TrimlyWidgetExtension.entitlements`) with:
   - `com.apple.developer.icloud-container-identifiers = ["iCloud.com.refractored.trimtally"]`
   - `com.apple.developer.icloud-services = ["CloudKit"]`
   - `com.apple.security.application-groups = ["group.com.refractored.trimtally"]`

No Swift code changes are needed at this step; this is purely configuration.

---

## Step 4: Share Core Types with the Widget Target

The current widget UI in [Trimly/Widget/TrimlyWidget.swift](../Trimly/Widget/TrimlyWidget.swift) refers to:
- `WeightUnit`.
- `WeightAnalytics.TrendDirection`.

To reuse these types in the widget:

1. Identify their definitions:
   - `WeightUnit` is likely defined in a model or utility file in `Trimly/Models` or `Trimly/Services`.
   - `WeightAnalytics.TrendDirection` is defined in [Trimly/Services/WeightAnalytics.swift](../Trimly/Services/WeightAnalytics.swift).
2. In Xcode, ensure the files containing these types are added to the `TrimTallyWidgetExtension` target:
   - Select each relevant Swift file (e.g., `WeightEntry.swift`, `WeightAnalytics.swift`, any file defining `WeightUnit`).
   - In File Inspector → **Target Membership**, check `TrimTallyWidgetExtension`.
3. Keep an eye on dependencies: any file you add to the widget target must compile in that context.
   - Avoid pulling in heavy dependencies that are not available in a widget environment (e.g., direct HealthKit usage if not strictly needed).
   - If `WeightAnalytics` has HealthKit-related code, consider:
     - Marking that code with `#if canImport(HealthKit)` guards, or
     - Extracting purely weight-related analytics (trend/delta) into a lightweight helper that both the main app and widget can share.

Goal of this step: make `WeightUnit` and `WeightAnalytics.TrendDirection` usable in the extension with minimal extra dependencies.

---

## Step 5: Define a SwiftData Container for the Widget (Option A)

If you choose to have the widget read directly from SwiftData + CloudKit:

1. Create a small helper in the widget target (or a shared file included in both app and widget):

   - Responsibilities:
     - Define a `Schema` with the same models: `WeightEntry`, `Goal`, `AppSettings`.
     - Initialize a `ModelContainer` with `cloudKitDatabase: .automatic` (matching the main app’s `DataManager` configuration).
   - This helper should be light and focused solely on read operations.

2. Example design (pseudocode, to be implemented later):

   - `WidgetDataProvider` with:
     - A static `shared` instance.
     - Lazy `ModelContainer` property.
     - Functions like `loadLatestWeightSummary()` returning a simple struct: `currentWeight`, `unit`, `delta`, `trend`.

3. Ensure the same iCloud container and schema are used so the widget receives the same synchronized data as the app.

If you prefer Option B (app-group summary) instead, you can skip SwiftData in the widget and return to this later.

---

## Step 6: Implement Real Data Fetching in `WeightProvider`

Once the widget has access to the necessary types and (optionally) SwiftData:

1. Update `WeightProvider` in [Trimly/Widget/TrimlyWidget.swift](../Trimly/Widget/TrimlyWidget.swift):

   - `placeholder(in:)` can continue returning static sample data.
   - `getSnapshot(in:completion:)`:
     - For `.isPreview` contexts, return a simple static entry.
     - For running on device, optionally call the shared data helper to provide a more realistic snapshot.
   - `getTimeline(in:completion:)`:
     - Use the data helper (SwiftData or app-group summary) to fetch current stats.
     - Construct a `WidgetTimelineEntry` with:
       - `date`: `Date()`.
       - `weight`: current weight in display units.
       - `unit`: `WeightUnit` from settings.
       - `delta`: weight change over a recent window (e.g., last 7 days).
       - `trend`: `WeightAnalytics.TrendDirection` based on that history.
     - Define `nextUpdate` (e.g., `Calendar.current.date(byAdding: .minute, value: 30, to: Date())`).
     - Create a `Timeline(entries: [entry], policy: .after(nextUpdate))` and pass to `completion`.

2. Keep timeline generation resilient:
   - If data fetch fails or there are no entries, fall back to a neutral placeholder (e.g., weight 0.0, delta 0.0, `trend: .stable`).

This step makes the widget actually reflect the user	s real data.

---

## Step 7: Trigger Widget Reloads from the Main App

To keep the widget up to date when the user logs a new weight:

1. In the main app target, import `WidgetKit` where appropriate (likely in `DataManager` or a higher-level coordinator).
2. After successful writes of `WeightEntry` (e.g., in `DataManager.addWeightEntry` or equivalent), call:

   - `WidgetCenter.shared.reloadTimelines(ofKind: "TrimlyWidget")`

   where `"TrimlyWidget"` matches the `kind` property in `TrimlyWidget`.

3. For broader updates (e.g., settings changes that affect units), you can use:

   - `WidgetCenter.shared.reloadAllTimelines()`.

This ensures widgets re-query the data source soon after important changes, rather than waiting only on the system	s schedule.

---

## Step 8: Testing and Validation

1. **Build and run the app** in Debug with widgets enabled.
2. On an iOS simulator or device:
   - Long-press on the home screen → **Edit Home Screen** → `+` → add TrimTally widget.
3. Verify:
   - Widget loads without errors (check Xcode console for extension logs).
   - Weight, delta, and trend match what the main app shows.
   - Unit (kg / lb) follows `AppSettings`.
4. Log a new weight in the app:
   - Confirm that widgets update within a reasonable time after calling `WidgetCenter` reload APIs.

For more detailed QA, test multi-device iCloud sync scenarios to ensure widgets on different devices see consistent data once CloudKit sync completes.

---

## Optional: App-Group Summary Optimization (Option B)

If SwiftData initialization overhead in the widget becomes a concern, you can introduce an app-group-backed summary:

1. Define a small, codable `WeightSummary` struct (weight, unit, delta, trend, timestamp).
2. In the main app, after computing analytics for dashboard, write `WeightSummary` to:

   - `UserDefaults(suiteName: "group.com.refractored.trimtally")` or a small file inside the app group container.

3. In the widget extension:
   - Read the latest `WeightSummary` from the app group.
   - Use it directly to construct `WidgetTimelineEntry` without touching SwiftData.

This can coexist with CloudKit: the app remains responsible for computing the summary whenever it has up-to-date SwiftData, and the widget simply consumes the last known summary value.

---

## Checklist Summary

When you	re ready to implement, use this as a quick checklist:

- [ ] Create `TrimTallyWidgetExtension` target in Xcode.
- [ ] Add `Trimly/Widget/TrimlyWidget.swift` to the widget target.
- [ ] Remove/merge the default starter widget file from the extension.
- [ ] Add App Groups + iCloud (CloudKit) capabilities to the widget extension.
- [ ] Share `WeightUnit` and `WeightAnalytics.TrendDirection` with the widget target.
- [ ] Implement a shared data helper (SwiftData container **or** app-group summary).
- [ ] Update `WeightProvider.getTimeline` to use real data instead of hard-coded values.
- [ ] Call `WidgetCenter.shared.reloadTimelines(ofKind: "TrimlyWidget")` from the main app after relevant data changes.
- [ ] Test adding the widget on device/simulator and validate correct values & updates.

Once these steps are complete, TrimTally will have a fully integrated, data-driven widget that stays in sync across devices via CloudKit.